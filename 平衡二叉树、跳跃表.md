## 平衡二叉树、跳跃表
> 本节原理性东西多，红黑树只需要明白原理即可，真正的实现过程比较复杂。

#### 目录
1. 平衡二叉搜索树（AVL树，红黑树）；
2. 实战：跳表——Redis内部的数据结构
3. 实战：树堆——最容易实现的平衡树之一

### 一. 平衡二叉搜索树（AVL树，红黑树）
1. 二叉搜索树 Binary Search Tree
	- 1.二叉搜索树是一颗满足如下性质（BST性质）的二叉树：
		- 任意节点的关键码>=它左子树中所有节点的关键码
		- 任意节点的关键码<=它右子树中所有节点的关键码
	- 2.根据以上性质，二叉搜索树的中序遍历必然为一个有序序列
	- 3.查询、插入、求前驱、求后继、删除操作的时间复杂度：
		- 随机数据期望O(log N);
		- 在非随机数据中，BST容易退化为O(N); 比如链表。
	- 4.保证性能的关键：左右子树节点数平衡； 	
2. AVL树-平衡二叉搜索树
	- 1.平衡因子Balance Factor:
		- 一个节点的左子树的高度减去它的右子树的高度。
	- 2.AVL树
		- 任意节点的平衡因子的绝对值都不超过1，即balance factor &#8712;{-1, 0, 1};
		- 每个节点需要保存：原始数据、左子节点、右子节点、子树高度；
	- 3.AVL树在插入、删除时，沿途更新节点的高度值
		- 当平衡因子的绝对值大于1时，触发树结构的修正，通过旋转操作来进行平衡。
	- 4.插入会打破 AVL性质，需要进行旋转
	- 5.旋转场景
		- 场景1：LL 左左子树：右旋
		- 场景2：RR 右右子树：左旋
		- 场景3：LR 左右子树：先左旋、在右旋
		- 场景4: RL 右左子树：先右旋、在左旋
		- ![旋转](https://upload.wikimedia.org/wikipedia/commons/c/c7/Tree_Rebalancing.png)
	- 插入过程简述：
		- 插入一个节点的时候，比右大走右，比左小走左，最后递归停留在可插入的位置，开始回溯时，更新树高，然后checked平衡因子是否{0,1，-1}，如果不是则进行旋转

3. 红黑树Red-black Tree
	- 1.红黑树是一种近似平衡的二叉搜索树
		- 从根到叶子的最长路径 <= 2倍的最短路径（简记：高度差在2倍以内）
	- 2.规则：
		- 每个节点要么是红色，要么是黑色。
		- 根节点是黑色
		- 最底层视作有一层空叶节点，是黑色的
		- 不能有两个相邻的红色节点
		- 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点
	- 3.正是因为它的红黑关系保证了根到叶子的最长路径<=2倍的最短路径
	- 4.规则被打破时，通过变色或者旋转来操作
		- 有非常多的情况，有时间在仔细的研究
	- 5.相比AVL树，红黑树插入删除更快（旋转少）、更省空间（颜色vs平衡因子）；
	- 6.红黑树是需要语言中有序集合，有序映射（例如C++ Set, Map）的内部实现方式；
	- ![红黑树](https://upload.wikimedia.org/wikipedia/commons/thumb/6/66/Red-black_tree_example.svg/450px-Red-black_tree_example.svg.png)

### 二. 跳表（Skip List）
1. 跳表是对有序的链表的优化，对标的是平衡树和二分查找
	- 1.区别
		- 二分查找：可以在数组上O(logN)查询，不可修改序列（不能用于链表）
		- 平衡树： 支持高效的查询、插入、删除，但是比较复杂，不容易实现；
	- 2.跳表是一种查询、插入、删除都是O(logN)的数据结构；
	- 3.跳表特点是原理简单、容易实现、方便扩展、效率优秀、在Redis、LevelDB等热门项目中用于代替平衡树。
	- 4.链表插入、删除都是O(1),但查询很慢——O(N); 
		- 跳表的核心思想：如何提高有序链表的查询效率？
2. 

### 三. 实战：树堆Treap


