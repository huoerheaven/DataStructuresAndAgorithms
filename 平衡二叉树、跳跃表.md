## 平衡二叉树、跳跃表
> 本节原理性东西多，红黑树只需要明白原理即可，真正的实现过程比较复杂。

#### 目录
1. 平衡二叉搜索树（AVL树，红黑树）；
2. 实战：跳表——Redis内部的数据结构
3. 实战：树堆——最容易实现的平衡树之一

### 一. 平衡二叉搜索树（AVL树，红黑树）
1. 二叉搜索树 Binary Search Tree
	- 1.二叉搜索树是一颗满足如下性质（BST性质）的二叉树：
		- 任意节点的关键码>=它左子树中所有节点的关键码
		- 任意节点的关键码<=它右子树中所有节点的关键码
	- 2.根据以上性质，二叉搜索树的中序遍历必然为一个有序序列
	- 3.查询、插入、求前驱、求后继、删除操作的时间复杂度：
		- 随机数据期望O(log N);
		- 在非随机数据中，BST容易退化为O(N); 比如链表。
	- 4.保证性能的关键：左右子树节点数平衡； 	
2. AVL树-平衡二叉搜索树
	- 1.平衡因子Balance Factor:
		- 一个节点的左子树的高度减去它的右子树的高度。
	- 2.AVL树
		- 任意节点的平衡因子的绝对值都不超过1，即balance factor &#8712;{-1, 0, 1};
		- 每个节点需要保存：原始数据、左子节点、右子节点、子树高度；
	- 3.AVL树在插入、删除时，沿途更新节点的高度值
		- 当平衡因子的绝对值大于1时，触发树结构的修正，通过旋转操作来进行平衡。
	- 4.插入会打破 AVL性质，需要进行旋转
	- 5.旋转场景
		- 场景1：LL 左左子树：右旋
		- 场景2：RR 右右子树：左旋
		- 场景3：LR 左右子树：先左旋、在右旋
		- 场景4: RL 右左子树：先右旋、在左旋
		- ![旋转](https://upload.wikimedia.org/wikipedia/commons/c/c7/Tree_Rebalancing.png)
	- 插入过程简述：
		- 插入一个节点的时候，比右大走右，比左小走左，最后递归停留在可插入的位置，开始回溯时，更新树高，然后checked平衡因子是否{0,1，-1}，如果不是则进行旋转

3. 红黑树Red-black Tree
	- 1.红黑树是一种近似平衡的二叉搜索树
		- 从根到叶子的最长路径 <= 2倍的最短路径（简记：高度差在2倍以内）
	- 2.规则：
		- 每个节点要么是红色，要么是黑色。
		- 根节点是黑色
		- 最底层视作有一层空叶节点，是黑色的
		- 不能有两个相邻的红色节点
		- 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点
	- 3.正是因为它的红黑关系保证了根到叶子的最长路径<=2倍的最短路径
	- 4.规则被打破时，通过变色或者旋转来操作
		- 有非常多的情况，有时间在仔细的研究
	- 5.相比AVL树，红黑树插入删除更快（旋转少）、更省空间（颜色vs平衡因子）；
	- 6.红黑树是需要语言中有序集合，有序映射（例如C++ Set, Map）的内部实现方式；
	- ![红黑树](https://upload.wikimedia.org/wikipedia/commons/thumb/6/66/Red-black_tree_example.svg/450px-Red-black_tree_example.svg.png)

### 二. 跳表（Skip List）
1. 跳表是对有序的链表的优化，对标的是平衡树和二分查找
	- 1.区别
		- 二分查找：可以在数组上O(logN)查询，不可修改序列（不能用于链表）
		- 平衡树： 支持高效的查询、插入、删除，但是比较复杂，不容易实现；
	- 2.跳表是一种查询、插入、删除都是O(logN)的数据结构；
	- 3.跳表特点是原理简单、容易实现、方便扩展、效率优秀、在Redis、LevelDB等热门项目中用于代替平衡树。
	- 4.链表插入、删除都是O(1),但查询很慢——O(N); 
		- 跳表的核心思想：如何提高有序链表的查询效率？
2. 

### 三. 树堆Treap
1. 特性
	- 1.是一个随机附加域满足堆性质的二叉搜索树，其结构相当于以随机数据插入的二叉搜索树。
	- 2.其基本操作的期望时间复杂度为O(log n).相对于其他的平衡二叉树的特点是实现简单，且能基本实现随机平衡的结构。
2. 介绍：
	- 1.Treap一词由Tree和Heap两次合成来。其本身是一颗二叉搜索树，它的左子树和右子树也分别是一个Treap, 和一般二叉搜索树不同的是，Treap为每个节点记录优先级。
	- 2.Treap在以关键码构成的二叉搜索树的同时，其节点优先级还满足堆的性质。
	- 3.Treap维护堆性质的方法用到了旋转，且只需要进行两种旋转操作，因此编程复杂度觉Splay要小一些。
3. 插入：
	- 1.给节点随机分配一个优先级，先和二叉搜索树的插入一样，先把要插入的点插入到一个叶子上，然后跟维护堆一样，如果当前节点的优先级比根大就旋转
	- 2.如果当前节点是跟的左儿子就右旋如果是跟的右儿子就左旋；
	- 3.由于旋转是O(1)的，最多进行h次（h是数的高度），插入的复杂度是O(h)的。在期望情况下`h=O(logn)`,所以它的期望复杂度是O(logn);
4. 删除：
	- 1.因为Treap满足堆性质，所以需要把删除的节点旋转到叶子节点上，然后直接删除。
	- 2.具体的方法就是每次找到优先级最大的儿子，向与其相反的方向旋转，直接那个节点旋转到了叶子节点，然后就直接删除。
	![Treap的插入](https://pic.leetcode-cn.com/1629111960-hWlQWl-%7B73aa7f62-f875-4285-86cc-c939956deb52%7D.png)
5. 查找
	- 1.和一般的二叉搜索树一样，但是由于Treap的随机化结构，Treap中查找的期望复杂度是O(log n);

