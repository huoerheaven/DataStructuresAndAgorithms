## [平衡二叉搜索树](https://zh.wikipedia.org/wiki/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9)、[跳跃表](https://zh.wikipedia.org/wiki/%E8%B7%B3%E8%B7%83%E5%88%97%E8%A1%A8)
> 本节原理性东西多，红黑树只需要明白原理即可，真正的实现过程比较复杂。

#### 目录
1. 平衡二叉搜索树（AVL树，红黑树）；
2. 实战：树堆——最容易实现的平衡树之一
3. 实战：跳表——Redis内部的数据结构

### 一. 平衡二叉搜索树（AVL树，红黑树）
1. 二叉搜索树 Binary Search Tree
	- 1.二叉搜索树是一颗满足如下性质（BST性质）的二叉树：
		- 任意节点的关键码>=它左子树中所有节点的关键码
		- 任意节点的关键码<=它右子树中所有节点的关键码
	- 2.根据以上性质，二叉搜索树的中序遍历必然为一个有序序列
	- 3.查询、插入、求前驱、求后继、删除操作的时间复杂度：
		- 随机数据期望O(log N);
		- 在非随机数据中，BST容易退化为O(N); 比如链表。
	- 4.保证性能的关键：左右子树节点数平衡； 	
2. AVL树-平衡二叉搜索树
	- 1.平衡因子Balance Factor:
		- 一个节点的左子树的高度减去它的右子树的高度。
	- 2.AVL树
		- 任意节点的平衡因子的绝对值都不超过1，即balance factor &#8712;{-1, 0, 1};
		- 每个节点需要保存：原始数据、左子节点、右子节点、子树高度；
	- 3.AVL树在插入、删除时，沿途更新节点的高度值
		- 当平衡因子的绝对值大于1时，触发树结构的修正，通过旋转操作来进行平衡。
	- 4.插入会打破 AVL性质，需要进行旋转
	- 5.旋转场景
		- 场景1：LL 左左子树：右旋
		- 场景2：RR 右右子树：左旋
		- 场景3：LR 左右子树：先左旋、在右旋
		- 场景4: RL 右左子树：先右旋、在左旋
		- ![旋转](https://upload.wikimedia.org/wikipedia/commons/c/c7/Tree_Rebalancing.png)
	- 插入过程简述：
		- 插入一个节点的时候，比右大走右，比左小走左，最后递归停留在可插入的位置，开始回溯时，更新树高，然后checked平衡因子是否{0,1，-1}，如果不是则进行旋转

3. 红黑树Red-black Tree
	- 1.红黑树是一种近似平衡的二叉搜索树
		- 从根到叶子的最长路径 <= 2倍的最短路径（简记：高度差在2倍以内）
	- 2.规则：
		- 每个节点要么是红色，要么是黑色。
		- 根节点是黑色
		- 最底层视作有一层空叶节点，是黑色的
		- 不能有两个相邻的红色节点
		- 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点
	- 3.正是因为它的红黑关系保证了根到叶子的最长路径<=2倍的最短路径
	- 4.规则被打破时，通过变色或者旋转来操作
		- 有非常多的情况，有时间在仔细的研究
	- 5.相比AVL树，红黑树插入删除更快（旋转少）、更省空间（颜色vs平衡因子）；
	- 6.红黑树是需要语言中有序集合，有序映射（例如C++ Set, Map）的内部实现方式；
	- ![红黑树](https://upload.wikimedia.org/wikipedia/commons/thumb/6/66/Red-black_tree_example.svg/450px-Red-black_tree_example.svg.png)

### 二. 树堆Treap
1. 特性
	- 1.是一个随机附加域满足堆性质的二叉搜索树，其结构相当于以随机数据插入的二叉搜索树。
	- 2.其基本操作的期望时间复杂度为O(log n).相对于其他的平衡二叉树的特点是实现简单，且能基本实现随机平衡的结构。
2. 介绍：
	- 1.Treap一词由Tree和Heap两次合成来。其本身是一颗二叉搜索树，它的左子树和右子树也分别是一个Treap, 和一般二叉搜索树不同的是，Treap为每个节点记录优先级。
	- 2.Treap在以关键码构成的二叉搜索树的同时，其节点优先级还满足堆的性质。
	- 3.Treap维护堆性质的方法用到了旋转，且只需要进行两种旋转操作，因此编程复杂度觉Splay要小一些。
3. 插入：
	- 1.给节点随机分配一个优先级，先和二叉搜索树的插入一样，先把要插入的点插入到一个叶子上，然后跟维护堆一样，如果当前节点的优先级比根大就旋转
	- 2.如果当前节点是跟的左儿子就右旋如果是跟的右儿子就左旋；
	- 3.由于旋转是O(1)的，最多进行h次（h是数的高度），插入的复杂度是O(h)的。在期望情况下`h=O(logn)`,所以它的期望复杂度是O(logn);
4. 删除：
	- 1.因为Treap满足堆性质，所以需要把删除的节点旋转到叶子节点上，然后直接删除。
	- 2.具体的方法就是每次找到优先级最大的儿子，向与其相反的方向旋转，直接那个节点旋转到了叶子节点，然后就直接删除。
	![Treap的插入](https://pic.leetcode-cn.com/1629111960-hWlQWl-%7B73aa7f62-f875-4285-86cc-c939956deb52%7D.png)
5. 查找
	- 1.和一般的二叉搜索树一样，但是由于Treap的随机化结构，Treap中查找的期望复杂度是O(log n);

### 三. 跳表（Skip List）
1. 介绍	跳表是对有序的链表的优化，对标的是平衡树和二分查找
	- 1.区别
		- 二分查找：可以在数组上O(logN)查询，不可修改序列（不能用于链表）
		- 平衡树： 支持高效的查询、插入、删除，但是比较复杂，不容易实现；
	- 2.跳表是一种查询、插入、删除都是O(logN)的数据结构；
	- 3.跳表特点是原理简单、容易实现、方便扩展、效率优秀、在Redis、LevelDB等热门项目中用于代替平衡树。
	- 4.链表插入、删除都是O(1),但查询很慢——O(N); 
		- 跳表的核心思想：如何提高有序链表的查询效率？
2. 查询
	- 1.从最高级索引、头元素起步
	- 2.沿着索引查找，直至找到一个大于或等于目标的元素，或者到达索引末尾
	- 3.如果该元素等于目标，则表明目标已经被找到，算法结束
	- 4.如果该元素大于目标或已经到达末尾，则回到当前索引的上一个元素，转入下一级索引，重复2；
	- 5.在一次的查询中，每一层最多遍历3个节点
		- 最高级索引只有2个节点
		- 每一级索引遍历的第3个节点必然大于目标——不然的话在上一级索引中应该走的更远才对，
		- 时间复杂度: <= 3*层数 = O(logN)
		- 空间复杂度：O(N)
			1. 索引的层数: O(logN)
			2. 每层索引的节点数： N/2+N/4+N/8+...<N
			3. 整个跳表的节点总数大约为2N (N是原始数据+N个索引节点)
	- 6.也可以是每3个节点为一个索引：
		- 这样可以更加节省一点空间，但是响应的造成查询的效率略微下降（每层之多遍历3个节点->4个）
		- 复杂度不变，常数有变化（时间和空间的平衡）；
3. 插入
	- 1.问题：先查询，在插入？
		- 插入很多次后，一个索引节点代表的节点数量会增多，如果不更新索引，时间复杂度会退化。
	- 2.解决方案：
		- 重建？ ——效率太低！
		- 在每个节点上记录它代表的下一个节点个数？——需要维护额外的信息，实现复杂
	- 3.跳表选择的方案是：利用随机+概率！
4. 随机建立索引
	- 1.现实中跳表不限制“每2个节点建立一个索引”， 而是：
		- 在原始数据中随机n/2个元素建立一级索引。
		- 在一级索引中随机n/4个元素建立二级索引。
		- 在二级索引中随机n/8个元素建立三级索引。
		- ......
	- 2.当元素比较多时，可以期望随机出来的索引分布比较均匀；
	- 3.查询的时间复杂度依旧是O(logN);
5. 概率更新索引
	- 1.当插入一个元素时，如何决定是否更新索引尼？
	- 2.跳表实现了一个特别的“骰子”，可能返回1~MAX_LEVEL之间的整数
		- 1/2概率返回1，表示不需要更新索引，直接在原始链表中插入即可。
		- 1/4概率返回2，表示需要为这个新元素建立一级索引，
		- 1/8概率返回3，表示需要为这个新元素建立一级和二级索引，
		- 1/16概率返回4，表示需要为这个新元素建立一级和三级索引。
		- ......
	- 3.通过这个“骰子”可以保证，无论插入多少元素，各级索引的节点数量期望依旧是N/2,N/4,......
	- 4.时间复杂度是O(logN)
6. 删除
	- 1.删除元素很简单，还是基于查询。
	- 2.在此过程中把原始链表和各级索引中对应的节点（如果有个话）都删除掉就可以了。
	- 时间复杂度是O(logN)；

	![跳跃表](https://upload.wikimedia.org/wikipedia/commons/thumb/8/86/Skip_list.svg/400px-Skip_list.svg.png);




